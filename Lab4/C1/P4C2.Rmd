---
title: "Analisando Commits no Git"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(resample) # <-- Para bootstrap!
library(GGally)
theme_set(theme_bw())

dados  = read_csv("dados.csv") %>%
  filter(file_extension %in% c("js", "py")) 

dados$date <- paste(dados$the_year, dados$the_month, dados$month_day, sep = "-")

dados = dados %>%
  mutate(day = weekdays(as.Date(date,'%Y-%m-%d')))
```


## Introdução

Neste checkpoint irei avaliar a popularidade, utilizando a quantidade de usuários do github, associados aos dias de semana, diferenciando entre os dias de semana e os finais de semana.

Irei avaliar os arquivos com extensão **js**(JavaScript) e **py**(Python), no qual a partir da amostra que temos cedida pelo github faremos uma inferência sobre a população utilizando um estimador, neste caso optei por utilizar a mediana.

** REVER ISSO AQUI. Queremos estimar qual a diferença da popularidade entre os dias da semana (a estatística) entre todos os usuários (a população) a partir do cálculo da proporção de pessoas que gostou do produto (a mesma estatística) em um teste prévio com 100 pessoas (a amostra). **

## Desenvolvimento

Para podermos fazer a inferência na população, iremos utilizar a técnica de boostrapping.

```{r}

semana <- dados %>%
  filter(day %in% c("segunda-feira", "terça-feira",  "quarta-feira",  "quinta-feira",  "sexta-feira"))

fim.semana <- dados %>%
  filter(day %in% c("sábado", "domingo"))

dados.semana <- semana %>%
  group_by(file_extension) %>%
  summarise(media = mean(users), mediana = median(users), sum = sum(users), numobser = n())

dados.final.semanada <- fim.semana %>%
  group_by(file_extension) %>%
  summarise(media = mean(users), mediana = median(users), sum = sum(users), numobser = n())
```
A amostra tem os seguintes dados:




Porém, nosso questionamento agora é sobre a população, tendo em vista que temos apenas uma amostra é necessário que façamos uma inferência para que a partir dela obtivamos dados da populção.
Para inferir sobre os dados iremos utilizar a técnica bootstrap. **EXPLICAR**.

```{r}
repeticoes = 4000 # pelo menos 2000, mas mais não faz mal.

exp_com_bootstrap <- function(x){
  boot_x <- sample(x, size = NROW(x), replace = TRUE) # aqui é o bootstrap
  return(mean(boot_x))
}

# Agora o input das reamostragens é a amostra!
experimentos.semana = data_frame(i = 1:repeticoes) %>% 
  rowwise() %>% 
  mutate(media_exp = exp_com_bootstrap(semana$users)) # <- Aqui!

experimentos.fim.semana = data_frame(i = 1:repeticoes) %>% 
  rowwise() %>% 
  mutate(media_exp = exp_com_bootstrap(fim.semana$users)) # <- Aqui!

ggplot(experimentos.semana, aes(x = media_exp)) + 
  geom_histogram(binwidth = 1, colour = "darkorange", fill = "white")
summary(experimentos.semana)

ggplot(experimentos.fim.semana, aes(x = media_exp)) + 
  geom_histogram(binwidth = 1, colour = "darkorange", fill = "white")
summary(experimentos.fim.semana)

# IC com 95%: 
alpha = .05
ci = quantile(experimentos.semana$media_exp, 
              probs = c(alpha/2, 1 - alpha/2))

# IC com 95%: 
alpha = .05
ci = quantile(experimentos.fim.semana$media_exp, 
              probs = c(alpha/2, 1 - alpha/2))

ggplot(experimentos.semana, aes(x = media_exp)) + 
  geom_histogram(binwidth = 1, colour = "darkorange", fill = "white") + 
  geom_vline(aes(xintercept = ci[[1]]), colour = "blue") + 
  geom_vline(aes(xintercept = ci[[2]]), colour = "blue") 

ggplot(experimentos.fim.semana, aes(x = media_exp)) + 
  geom_histogram(binwidth = 1, colour = "darkorange", fill = "white") + 
  geom_vline(aes(xintercept = ci[[1]]), colour = "blue") + 
  geom_vline(aes(xintercept = ci[[2]]), colour = "blue")


```